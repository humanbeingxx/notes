# 为什么epoll的边缘触发方式必须使用non-blocking

epoll和读写的四种模式组合：水平触发和阻塞读写，水平触发和非阻塞读写，边缘触发和阻塞读写，边缘触发和非阻塞读写。

后面都是以读为例。每次读都是基于buffer，buffer的大小是有限的，所以需要分多次读。

下面是一个猜测，buffer的数据是内核写入的，每次读完buffer的数据，内核会继续向buffer中填充剩余数据。

在阻塞模式下，程序并不知道什么时候读写完成，当没有数据可读时，会阻塞等待。非阻塞模式下，当读取完数据后，会得到一个EWOULDBLOCK的错误码，表示所有可读数据已经读完。

## 水平触发 + 阻塞模式

```java

while(true) {
    epoll();
    read_blocking();
}

```

是可行的。虽然阻塞模式无法知道什么时候数据读取完，但是每次调用read时，都是可以保证当前有可读数据，所以不会阻塞。

## 水平触发 + 非阻塞模式

```java

while(true) {
    epoll();
    read_non_blocking();
}

```

是可行的。既可以一次read固定长度数据，也可以通过循环读buffer，直到返回EWOULDBLOCK错误码。并且通过循环读，可以减少epoll系统调用的次数。

## 边缘触发 + 阻塞模式

在边缘触发下，必须在一次epoll之后读取完buffer中全部数据，因为边缘触发只会在状态变成可读时触发一次，如果不一次读取完，下次epoll将不会返回该fd，剩余的数据无法读出（除非再次触发可读，剩余的数据对于下次读来说是脏数据）。

如果用阻塞模式，循环读取buffer，会因为读取完全部数据后阻塞，无法进入下次epoll。

**这里对比`水平触发 + 阻塞模式`，为什么在水平触发下，阻塞是可行的？**

- 这里又有一个猜测：内核写入buffer时，并不能认为一定是分多次写，每次都优先写满。例如buffer是1k，数据有2.5k，先写1k，再写1k，再写0.5k。是不是有可能中间某一次写入的不是1k，而是0.8k。总之没有看到资料说可以假设每次都优先写满。也就是说不能认为某次读buffer，当buffer没有写满时就认为是最后一批数据。

水平触发下，只要buffer中有数据，在下次epoll时，仍作为就绪文件返回，阻塞读可以读取剩下的数据且不会阻塞。可以认为读时的阻塞转移到了epoll方法中，只要文件就绪就继续读，否则就阻塞在epoll方法。

## 边缘触发 + 非阻塞模式

是可行的。因为有EWOULDBLOCK，可以知道什么时候读取完数据。
