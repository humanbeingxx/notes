# 杂记

## 匹配中日韩

[\u4E00-\u9FA5\uF900-\uFA2D]

## normalize

一些语言包含语调符号和重音符号等，unicode中有两种表示方式。一种是用一个直接带重音符号的字符，另一种是合成符合，即用两个字符合成一个字符。

正则表达式compile过程有一个normalize过程，将不同表示方式转成统一形式。

标准等价：语义和视觉都等价。
兼容等价：语义等价，但视觉不等价。

NFC: 标准等价合成(Normalization Form Canonical Composition)，返回多个简单字符的合成字符。
NFD: 标准等价分解(Normalization Form Canonical Decomposition)，返回合成字符分解成的多个简单字符。
NFKC: 兼容等价合成，返回合成字符。
NFKD: 兼容等价分解，返回多个简单字符。

## \p \P

表示匹配一类字符。用法很多，举几个常用例子：

\p{L} 或者 \p{Letter} : 任意语言的字母

\p{N} 或者 \p{Number} : 数字

## 一个性能问题

以前遇到过经典的正则回溯性能问题：

用 `^(a*)+$` 匹配 `aaaaaaaaaaaaaaaaaab`

最近又遇到一个不涉及两层匹配的，但也会有性能问题。

两个正则的效果一样：

```
^(a|A|à|À|ả|Ả|ã|Ã|á|Á|ạ|Ạ|ă|Ă|ằ|Ằ|ẳ|Ẳ|ẵ|Ẵ|ắ|Ắ|ặ|Ặ|â|Â|ầ|Ầ|ẩ|Ẩ|ẫ|Ẫ|ấ|Ấ|ậ|Ậ)+$

^[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬ]+$
```

匹配字符 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa$

在vscode中，第一个表达式会假死，第二个表达式不会。即使a再多，也能正常执行。说明执行过程中，用|和用[]，是不同的处理方式。

- [ ] 用|和用[]有什么区别？

此外，在不同jdk中，正则表现也不同。

在java8中，表现和vscode一致。但在java22中，不会假死，甚至连经典的 `^(a*)+$` 也能正常执行。

- [ ] java22执行正则有什么优化？