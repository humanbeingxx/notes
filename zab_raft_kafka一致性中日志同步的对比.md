# zab_raft_kafka一致性中日志同步的对比

## raft

raft选举保证了新的主节点包含了最全的日志，从节点要做的就是服从主节点的日志数据。

raft的日志包含了term和index概念，term是任期，index是日志序号，是连续的。

从节点同步主节点数据时，会从后向前找到index相同且term相同的日志，在此之后的日志全部用主节点的数据覆盖。

且为了防止已提交的日志被覆盖，raft中不允许直接提交之前term的日志，而是采用了“捎带”的方式。

## zab

zab的选举比raft稍复杂，每个节点可以投出不止一票，好处是不会产生vote split，缺点是增加了选举时长。

且zab选举后会立即发起一次日志同步，保证集群内的数据是一致的。（raft也可以立即发起一次空提交达到类似效果）

***在raft和zab中，最新日志的定义都是全部日志中的最新一条，而不是已提交日志中的最新一条***

### raft和zab对之前leader中残存数据的处理

zab采用激进策略，无论过半还是未过半的日志，都认为已提交。

raft中会检查未提交日志在follower中包含情况，仅当过半时才会“捎带”提交。（疑问：没有过半的日志怎么办？保留还是删除？）

原因还是因为zab在选举后会强制主从同步数据，那么主节点的日志哪怕是没有过半，也会同步到从节点上。

## kafka

kafka和另外两种一致性不同，设计了ISR和AR的概念，在高一致性的配置下，ISR之间实际是强一致性的。且只要有一定数量的ISR活跃，就可以组成集群，并不需要AR全部活跃。

AR中不在ISR的部分的节点会尝试和主节点同步，完成前不会加入ISR。

kafka的选举比较简单，就是从ISR中任意找一个，没有像上面两种复杂的日志判断。而是重点处理了数据丢失和不一致问题。

当min.insync.replicas=-1时，每次写入都是强一致性，不会存在数据丢失和不一致，主要处理的是min.insync.replicas=1的情况。

kafka从节点同步主节点数据时，会带上当前的epoch，主节点返回该epoch结束下一条日志的位置，从节点从该位置开始复制日志。

## 一致性强弱对比

zookeeper对于同一个client，可以是强一致的。一个client只会连接一个server，只要保证该client发出的写，最终会在连接的server生效（如果是follower，必须保证同步成功）。

raft读写分离情况下，通过`Linearizable Read`策略保证强一致性。follower读请求会查询leader的readIndex（也就是查询时leader节点的commitIndex），仅当readIndex小于等于本地commitIndex才读取成功。