# 关于跳跃表时间复杂度的证明

zset底层实现有两种，当元素个数较少且元素体积较小时，使用ziplist实现，否则用skiplist实现。且为了方便快速查找元素对应的score，另外加上了hashmap保存。

skiplist的查找、插入、删除都是logN。下面证明查找的时间复杂度。

这里采用反推，即从最底层往高层，沿着查找路径反向推导。

在第k层，当前是x元素，那么对于k+1层，包含x元素的概率为p。那么有 1-p 的概率，需要在k层往左反向移动一步，有p的概率往上层移动一步。

用C(k)表示需要攀升k次的期望查找路径长度，那么C(k-1)表示需要攀升k-1次的期望路径长度，即C(k)的上一层。则有如下公式：

`C(k) = (1–p) (1 + C(k)) + p (1 + C(k–1))`

其中 1 + C(k–1) 表示往上爬一步，进入上一层。
1 + C(k) 中为什么要 +1 呢？因为在 1-p 的情况下已经确定了当前x值在上一层中不存在，需要往左移动重新找下一个x值。

化简后，有`C(k) = k/p`

下面需要定义一个层数。

理想情况下，是从有1/p个节点的层数开始搜索比较有效。
L层出现的元素期望个数是是 `n * p^(L-1)`，那么根据 `1/p = n * p^(L-1)`，可计算出 `L = log1/p(n)`。

从上可见层数是n的对数，那么有 `C(max)=(log1/p(n) - 1) / p`。从而是n的对数关系。

## zrank的复杂度

zrank获取元素的排名，复杂度也是logN。这里引入了新概念“跨度”来保持logN。

每一层的节点保存了到下一个节点需要跨过的节点数，那么当遍历到指定节点时，把每层的跨度相加，就是元素的排名。

插入时，会更新上一层前一个节点的跨度值并计算出新节点到下一个节点的跨度。