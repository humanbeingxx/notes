# 什么？代码大全？

## 耦合与内聚

### 耦合的种类（由强到弱）

#### 内容耦合(Content Coupling)

如果发生下列情形，两个模块之间就发生了内容耦合。

1. 一个模块直接访问另一个模块的内部数据；
2. 一个模块不通过正常入口转到另一模块内部；
3. 两个模块有一部分程序代码重叠；
4. 一个模块有多个入口。

#### 公共耦合(Common Coupling)

若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。

#### 外部耦合(External Coupling)

一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。

#### 控制耦合(Control Coupling)

如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。

#### 印记耦合/特征耦合(Stamp Coupling)

调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。
和数据耦合对比，我的理解是，特征耦合需要了解传入参数对象的具体结构特征，而数据耦合则传入的就是简单参数，不需要过多理解结构。

#### 数据耦合(Data Coupling)

如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合。

#### 非直接耦合(Nondirect Coupling)

如果两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，这就是非直接耦合。这种耦合的模块独立性最强。

### 各种内聚（从高到低）

#### 功能内聚

只执行一项操作。

#### 顺序内聚

包含需要按特定步骤执行的操作，前者的输出作为后者的输入。只有全部完成执行后才算完成整个操作。
可以将其中特定步骤独立成函数，并在原函数中调用。

#### 通信内聚

不同操作使用相同的数据，但不存在其他任何联系（特别是没有顺序关系）。
可以将其中特定步骤独立成函数，并在高层次函数中调用。

#### 临时内聚

需要同时执行的操作放在一起。除了需要同时，没有其他关系。
这个内聚可能不是很可取，至少需要将各个操作独立并在原来的函数中调用。

#### 过程内聚

包含需要按特定步骤执行的操作，和顺序内聚区别在于没有输入输出关系。
可以将其中特定步骤独立成函数，并在原函数中调用。

#### 逻辑内聚

将类似的操作放在一起，通过参数标志位控制哪些操作需要执行。
这个内聚可能不是很可取，至少需要将各个操作独立并在原来的函数中调用。

#### 巧合内聚

这个已经算不上内聚了。

### Demeter法则

“不要和陌生人说话”。

#### “朋友”的定义

1. 当前对象本身（this）
2. 以参量形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的对象
4. 当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友
5. 当前对象所创建的对象

应尽量减少类和类之前相互合作的范围，让下面几个数字最小：

- 所实例化的对象的种类
- 再被实例化对象上直接调用不同方法的数量
- 调用有其他对象返回的对象的方法的数量

## 零散知识点

前期准备的重点在于降低风险。准备工作倾向于集中改进需求分析和项目规划。

软件的首要技术使命是管理复杂度。

高代价、低效率的设计主要根源有下面三点：

1. 用复杂的方法解决简单问题。
2. 用简单但是错误的方法解决复杂问题。
3. 用不恰当的复杂方法解决复杂问题。

So,

1. 让同一时间需要处理的本质复杂度降低到最少。
2. 不要让偶然性的复杂度无谓的增长。

### 一些容易发生变化的区域

- 业务规则
- 对硬件的依赖（可以引申为对外部系统的依赖）
- 输入和输出
- 非标准的语言特性
- 困难的设计区域和构建区域
- 状态变量
  - 不要使用boolean类型作为状态变量
  - 使用访问器检查状态变量而不是直接对变量进行判断
- 数据量的变化

### 接口应该注意的

#### 尽可能让接口可编程，而不是表达语义

可编程部分由接口的数据类型和其他属性构成，能强制性要求；而语义部分则由“本接口将会被怎样使用”的假定组成。
使用断言或其他技术，避免接口被错误调用。

#### 谨防在修改时破坏接口的抽象 + 不要添加和抽象不一致的成员

#### 如何避免（减少）语义上破坏封装？

根据书中说法，不应该直接看接口的具体实现，而是应该联系作者，问其应该怎么使用。然后作者更新接口文档，将使用方法写清楚。

### 类质量 checklist

- 类是否有一个中心目的？
- 类名是否恰当，是否表达了中心目的？
- 类接口是否展示了一致的抽象？
- 类的接口是否让人清楚知道该怎么使用？
- 类的接口是否足够抽象，让你能不必顾虑是如何实现服务的？能当做黑盒吗？
- 类提供的服务是否足够完整，让其他类无须动用其内部数据？
- 是否从类中除去无关信息？
- 是否考虑过把类进一步分解成组件类？
- 在修改类时是否维持了其接口的完整性？
- 类中是否只有大约七个或更少的数据成员？
- 是否把类直接或间接调用其他类的子程序的数量减到最少？

### 关于传参是传递若干字段还是传递整个对象的讨论

支持只传递若干字段：可以最大程度减少函数之前的关联，降低耦合。把整个对象传递，潜在的把对象的全部访问器暴露给函数，破坏了对象的封装。
支持传递整个对象：可以在不改动接口的前提下，让函数灵活使用参数中其他字段，可以保持接口更稳定。而传递具体字段，才是破坏了封装。

作者的观点：关键是要看函数的抽象是什么。如果函数需要几个特定的参数，而这些参数恰好是在一个对象中，那么应该独立传递这些参数。如果函数表达的抽象是要一直持有某一个对象，且对这个对象进行各种操作，那应该传递整个对象。

（作者观点）一般来说，在调用函数之前进行装配操作（set up)或者调用之后进行拆卸（take down)的代码，都是函数设计不佳的表现。

### 关于变量

#### 使变量引用局部化

“攻击窗口” ： 介于同一变量不同引用点之间的代码。
把一个变量的引用点集中到一起是个比较好的做法。

#### 尽可能减少变量的生命周期

#### 减少作用域的一般原则

- 在循环即将开始时才初始化循环内的变量
- 直到变量即将被使用时才给变量赋值
- 把相关语句放一起
- 把相关语句组织成一个子函数
- 开始使用最严格的可见性，再逐步根据需要扩展

### 组织代码

#### 组织线性代码

- 设法组织代码，使依赖关系明显。如果可以的话，让下一句的入参是上一句的返回值，这样使用者可以自然的确认语句间关系
- 使函数能突显依赖关系
- 利用子函数入参明确显示依赖关系
- 用注释说明关系，用断言和校验检查依赖关系

#### 关于break的冷知识

如果有多层嵌套循环，怎么break跳出外层循环？
可以给每个循环定义一个标签，break label直接跳出对应循环。

#### 使用递归需要注意的

- 确认递归能退出
- 使用循环计数器防止无穷递归
- 把递归限制在一个函数中，不要多函数相互调用递归

#### java中的位运算操作符并不能导致短路

例如：
if ((a == 0) && (b / a == 0))  a为0 时短路
if ((a == 0) & (b / a == 0))   a为0 时不会短路

#### 减少嵌套层次的手段

##### 重复判断一部分条件

可以重复外层判断，将内层判断提取出来。

```java
if (level1) {
    System.out.println("level1");
    if (level2) {
        System.out.println("level2");
        if (level3) {
            System.out.println("level3");
            if (level4) {
                System.out.println("level4");
            }
        }
    }
}

// 修改为

if (level1) {
    System.out.println("level1");
}

if (level1 && level2) {
    System.out.println("level2");
}

if (level1 && level2 && level3) {
    System.out.println("level3");
}

if (level1 && level2 && level3 && level4) {
    System.out.println("level4");
}
```

##### 用break跳出判断

将嵌套放在 for...while(false) 中，在某些条件未满足时直接跳出。这个方法不常用。

##### 将深层次嵌套提取成函数

##### 使用更面向对象的方法/重新设计深层嵌套的方法

复杂的代码可能是由于没有完全理解代码的作用，所以无法简化。

## 软件质量

### 质量的特性

#### 外在特性

- 正确性。
- 可用性。用户学习和使用的容易程度。
- 效率。
- 可靠性。在指定的必需条件下，系统完成功能的能力，应该有很长的平均无故障时间。
- 完整性。系统组织对程序或者数据进行未验证或不正确访问的能力。既包括限制未授权的用户，也包括确保数据能正确访问。
- 适应性。为特定应用或环境设计的系统，在不做修改情况下，能在其他应用或环境中使用的范围。
- 精确性。评价输出结果的误差程度，主要是判断系统完成工作的优劣程度。
- 健壮性。

#### 内在特性

- 可维护性。是否能容易对系统进行修改，改变或者增加功能，提高性能以及修正缺陷。
- 灵活性。为特定应用或环境设计的系统，要在其他应用或环境中使用，需要对系统修改的程度。
- 可移植性。
- 可重用性。指系统的某些部分可被应用到其他系统中的程度，以及难以程度。
- 可读性。
- 可测试性。
- 可理解性。系统组织和细节语句的层次上理解整个系统的难易程度。与可读性相比，对系统提出了更高的内在一致性要求。

### 一套推荐的质量保证的阵容

1. 对所有需求、架构以及系统关键部分的设计进行正式检查。
2. 建模或者创建原型。
3. 代码阅读或者检查。
4. 执行测试。

### The best is the enemy of the good !

### 注释

#### 注释的种类

##### 重复代码

把代码翻译成注释，毫无用处。

##### 解释代码

解释复杂、有巧、敏感的代码块。通常是由于代码含糊不清，才需要这种注释，最好是改进代码。

##### 代码标记

类似todo这种。

##### 概述代码

将若干行代码，用一两句话概述。对于要修改这段代码的人来说，非常有用。

##### 代码意图说明

好的代码，应该能自说明干了什么。而目的性注释，主要是说明代码需要解决的问题，以及为什么要这么设计的原因等。

##### 代码无法传递的信息

版权声明、保密要求、版本号等。

#### 对接口或者函数的注释

- 注释接口假设
- 注释函数的局限性
- 注释函数的全局性效果。
- 记录所用算法的来源。