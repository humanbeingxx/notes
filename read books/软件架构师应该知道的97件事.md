# 读书笔记（常见的、已掌握的不记）

## 客户需求 > 个人简历

😠 心里不是想追求解决问题的最佳方案，而是希望借此丰富自己的简历！
😃 信誉远胜于时髦的编程技巧和流行的范式！

## 简化根本复杂，消除偶发复杂

- 本质复杂度和待求解问题的本质有关，是无法避免的。
- 偶然复杂度一般是因为选用求解问题的方法时所引入的，比如初次使用jpa。

😠 警惕象牙塔里的产品，分析方案中有多少代码是直接解决业务问题。量体裁衣，为问题制订合身的解决方案。

## 关键问题可能不是出在技术上 + 以沟通为中心，坚持简明清晰的表达方式和开明的领导风格

如果有人工作方式不正确怎么办？**沟通**

- 不要把对话当成对抗
- 不要带着情绪和人沟通
- 尝试通过沟通设定共同点目标

沟通必须**简明清晰**

- 简单的图表
- 非正式的白板会议
- 拍下内容，通过wiki分享
- 详细记录讨论结果
- 让开发人员参与架构的制订过程

## 架构才是决定应用性能的根本因素 ？？没看懂

## 分析需求背后的意义

- 定位真正的问题，提出更好、成本更低的解决方案。把最有价值的需求摆放在第一位。
- 客户合作重于合同谈判。

## 我们常常忽略了自己在谈判

- 什么是工程？统筹全局、权衡利弊、适当妥协。
- 谈判时，不能再对方第一个要求上妥协让步。

## 量化需求

- 缺乏客观的标准，只能任凭挑剔的用户和偏执的程序员摆布。
- 用一些简单的问题量化需求：数量有多少？在什么阶段？有多频繁？不能超过过长时间？增加还是减少？占多大比例？这些应该包含在业务策划方案里。
- 如果有人提出可伸缩的要求，要问清楚新用户从哪来？为什么数量会增加？何时增加？增加多少？

## 一行代码比五百行架构说明更有价值

软件项目的最终目标是建立声场体系，设计只是达成目标的手段，不是目标

## 不存在放之四海而皆准的解决方案

## 提前关注性能问题

😠 在项目周期的最后阶段才关注性能，会导致错失大量历史信息，包含性能变化的细节。
=> 当性能出现问题时，只须检查最近的变化。

## 草率提交任务是不负责任的行为

我的看法

- 提交前必须通过编译
- 必须通过sonar检查
- 修改公用代码、别人的代码，必须保证测试通过
- **提高系统的自动化测试功能**

## 业务目标至上

- 项目启动前，指定计划，明确投资回报率。避免做出错误的技术决策，造成经费超支。无论是和业务部门讨论功能，还是和开发团队讨论设计与实现，都要把**高投资回报率**当做目标
- 软件开发人员可以制定技术决策，但通常不应该参与业务决策。业务部门应该为技术提供指导并制定业务决策。架构师要沟通协调，既保护软件架构，有坚持业务目标。

## 先确保解决方案简单可用，再考虑通用性和复用性

- 通过经验提炼的简单方案，远胜过不切实际的通用方案。
- “先简单后通用”远侧可以作为最终的评判标准。

## 持续集成

一套频繁对应用程序进行自动化测试和构建的实践方法，以及确保测试和构建自动执行的相关工具。

注：*这个有点难度*

## 避免进度调整失误

调整中，最可怕的是 ***时间不变，任务量增加；任务不变，截止日期提前。***

改变计划会带来一下问题：

1. 仓促决定的进度会导致拙劣的设计，引发质量问题。
2. 仓促完成的代码，直接导致最终bug增加。
3. 紧张的测试进度会导致测试不充分，直接增加测试中可能出现的问题。
4. 以上几点都会引发质量问题，解决这些问题成本更高。
5. 如果必须加快进度，可以尝试去掉一些不重要的功能。

- [ ] 架构权衡分析方法 ATAM
- [ ] 成本收益分析方法 SEI

## 重视不确定性

- 当面临多种选择时，应仔细考虑设计中存在的不确定性。
- 不确定性促使推迟（决定应该基于足够的事实，而不是假定和猜测）决定，收集更多信息；促使用分隔和抽象的方法来降低设计决策的重要性（决策对系统的影响程度）。

😠 抱着头脑中最先闪现的想法不放，被其束缚，偶然性决策会占据上风。

## 让大家学会复用

- 知道它的存在
- 知道如何使用
- 认识到利用已有资源好过自己动手

## 架构里没有大写的I

😠 认为自己比客户更懂需求。
😠 认为开发人员只是来实现自己想法的资源。
😠 如果想法受到质疑或者旁人指出忽略了他人的意见，会极力辩解。

😄 驱动架构的是需求，不是架构师，任务是竭尽所能满足需求。
😄 重视团队合作。
😄 检查自己的工作，和团队一起检查架构对每项需求的支持情况。
😄 自我反省。

## 使用恰当的层次的试图

从架构图或者成品维度看，太抽象；从源代码角度看，细节太多。
多种度量标准：方法数、类扇出数、圈复杂度等。

## 先尝试后决策

应该持续关注马上要制订的决策。可以要求开发商量出解决方案，尝试一段时间，比较不同方案的优缺点。

## 程序设计师一种“设计”

- 程序设计是发现和学习的过程，不是生产和建造的过程。
- 可以采用一些已经被证明有效的管理方法，比如敏捷产品管理方法、精益生产方法。

## 控制项目规模

敏捷方法提倡 ***最简单有用的东西***

- 抓住真正的需求。不能创造价值的需求应该受到质疑。
- 分而治之。寻找机会将大项目分解成独立的小项目。
- 设置优先级。
- 尽快交付。

## 摩天大楼不可伸缩

无论是开发新项目，还是替换老系统，都应该逐个部署系统组件。

## 留意架构图重的空白区域

常用矩形表示程序或硬件，用箭头表示它们的关系。但这些矩形之间的空白，往往包含了大量的程序；箭头则包含大量的信息

## 学会软件专业的行话

### 一些反模式

#### 程序员篇

> http://blog.jobbole.com/87413/
- 过早优化
- 单车车库
- 上帝类
- 新增类恐惧症
- 内部平台效应
- 魔法数和字符串
- 无用的（幽灵）类

#### 综合类型

- 分析麻痹症
- 委员会设计
- 蘑菇管理
- 死亡征途

## 侏儒、精灵、巫师和国王

- 架构师应该熟悉各种人的性格特点，由不同性格的人组件团队。

## 架构师应聚焦于边界和接口

- 情景地图？
- 高内聚、低耦合
- 避免横向切分需要高度信息交换的区域

## 记录决策理由

记录软件架构决策的文档，长期有用且无需太多精力维护，有很高的投资回报价值。

### 基本内容

- 决策了什么？
- 为什么要这么决策？
- 还考虑过哪些方案？为什么没有采用？

### 作用

- 作为和开发人员沟通的工具，说明应遵循的架构基本原则。
- 当开发人员对架构提出质疑时，使团队能“就事论事”的讨论问题。
- 向经理和利益相关者说明架构设计的原因。
- 要把项目移交给别的架构师时。
- 最重要的作用是
  - 逼着自己明确说出理由，有助于确保基础是扎实稳固的。
  - 当相关条件发生变化时，需要对决策进行重新评估时，可以作为一个起点。

## 不要滥用架构隐喻

对于比较复杂、抽象和变化移动的目标，隐喻提供了很好的具体媒介。但滥用隐喻，会让人觉得隐喻越来越真实，相应了原本的目标。
不要沉溺与隐喻，只将之作为用于探索性沟通。

## 从“可行走的骨架”开始开发程序

## 数据是核心

对于了解管理庞大系统的复杂性，数据的结构处于核心地位。

## 确保简单的问题有简单的解

## 根据投资回报率决策

## 所有软件系统都是要遗留下来的系统

- 清晰性
- 可测性
- 正确性
- 可跟踪性

## 起码要有两个解决方案

## 小心“好主意“

## 拉伸关键维度，发现设计中的不足

- 了解基础设施的规范是否能应付增长的需求，圈出限制范围。
- 确认在预期的吞吐量下，系统不但能完成今天的任务，同时具备处理峰值的能力。
- 对当前数据访问方案进行校核，确保其在系统伸缩扩展时依然有效。
- 确保在系统负载升高时，能以增加硬件或转换处理路径的方式进行系统的伸缩扩展。

## 稳定的问题才能产生高质量的解决方案

最好的架构师不是解决难题，而是围绕着难题开展工作。将四处弥散的问题收集起来，画出其中的边界，确保对问题有稳定的、完整的认识。

## 对决策负责

1. 必须对决策过程有充分的认识。什么才叫完成了架构决策？
    - 决策以书面形式确定下来，必须经过校正核实，可追溯。
    - 必须已和执行该决策及会直接/间接接受其影响的人进行过沟通，达成共识。

2. 要定期对架构决策进行复审；对照检查决策的实际效果和预期结果；识别哪些是有效的决策，哪些是无效的。
3. 贯彻执行决策。
4. 可以将一些决策委托给领域的专家。

## 你的客户的客户才是你的客户

需求收集会议不是项目实现讨论会议。除非问题已经非常明确或大家都已理解，不要让客户使用与具体实现相关的术语。不要听任他们给出的所谓的解决方案。
牢牢关注客户的客户的需求。

## 选择彼此间可协调工作的框架

以微略不同的方式解决非常相似的解决方案，都会带来不必要的复杂性。概念或表示上的细微差别必须用杂碎的胶水代码打补丁或者映射。最后可能能用的两个框架核心功能的最小公分母。

## 不仅控制代码，也要控制数据

架构规划过程中，数据迁移容易被忽略。最终往往只作为一种补救措施，且由手工操作完成，相当脆弱。
要把数据库构建也作为自动化构建的一部分，做到一次性构建整个应用程序。

## 不要急于求解

有些软件问题根本不需要解决，之所以看似问题，只是因为我们只关注其表面问题。
应该学会不断拉近放远，确保正确锁定问题，而不是一味接收别人出的问题。在需求面前，不应该想个糖果盒，时刻掏出各色各样的聪明点子。
首先看看自己是否可以改变这个问题，如果不解决这个问题，系统架构会变成什么样？