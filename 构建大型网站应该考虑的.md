# 我的想法

## 软件架构层面

首先充分了解业务场景。是为了解决什么问题，目前的解决方案是什么，未来可能会向哪个方向发展。
了解项目目标和时间成本（deadline）

系统层次设计，最基本的是持久层、业务处理层、表示层。
业务处理层怎么划分模块，是否做成微服务。哪些东西可以先固化到主流程中，哪些应该做到子模块，哪些应该做成可配置化，是不是用第三方工具优化设计。

前期是否需要辅助模块，例如数据分析。

## 实现/硬件层面

考察系统qps，可达峰值，数据总量。

系统负载均衡。
针对高并发使用缓存。
针对数据量使用分库分表。
数据一致性，分布式事务。
哪些可以做成异步，可以用定时任务预处理。

容灾，冗余，数据备份。

系统监控方式。日志收集、分析平台。

## 安全方面

sql注入。
页面抓取。
用户关键信息的保护。

## 可用性/性能方面

可能常见问题，优雅降级，应急方案预备。
主要功能接口响应时间。

### 高并发秒杀

前端限制刷新频率。
可以使用redis控制商品数量。但是后续处理做成队列，异步执行。防止高并发操作数据库。

## 最终一致性分布式事务如何保障实际生产中99.99%高可用

### 分布式事务模型`X/Open DTP`

要求每个模块都支持XA，中央管理器先发出prepare消息给每个模块，模块创建本地事务，写入本地事务日志。中央管理器根据子模块返回的结果判断是进行回滚还是提交。最后释放事务过程中所有的锁。

目前用的很少，存在的问题如下：

1. 事务开始后，涉及到的业务数据都被锁，且hold时间比较长，在高并发和多模块情况下，对数据库性能影响大。
2. 业务越复杂，模块越多，局限性就越大，伸缩性差。
3. 要求模块支持XA。

### TCC

try-confirm-cancel，是二阶段提交的一种实现。

举例有一个主业务和两个从业务，需要保持一致，那么大致流程如下：

1. 主业务调用从业务a、b的try接口，同时活动管理器会记录下调用的try服务。
2. 主业务做本地事务操作。
3. 活动管理器检测到业务a、b的try操作执行成功，向a、b发出confirm命令。
4. 从业务a、b执行confirm。

调用try过程中如果有失败，则活动管理器会对每个调用过的try执行cancel。同样，在执行confirm过程中如果有失败，也会对所有执行过try的服务调用cancel，同时也会对主业务进行回滚。

TCC要求每个服务都提供对应的try、confirm、cancel接口。

在实现try、confirm、cancel时，可以在业务中加入中间状态和中间预留值。例如订单支付后给用户增加积分，修改积分时，可以将积分设置成修改中状态，但是这个只是系统内部状态，对用户不可见，积分值暂时不变，在多出来的预留值里保存需要增加的积分。当confirm时，将预留值加到积分值上。当cancel时，将预留值中的积分扣除即可。

#### TCC存在的疑问

1. 调用try接口和处理本地业务，整个流程是不是在一个本地数据库事务环境下？如果是，会不会事务时间过长，如果不是，如果调用try失败了，或者本地处理失败了，是直接回滚吗？
2. 调用try和处理本地的先后顺序。

按照网上关于seata的使用，是用一个事务管理器处理整个流程，也就是事务包裹了本地操作和远程的try-confirm-cancel调用。如果是一个事务，先后顺序如何定义？相比远程调用，本地操作失败的可能性应该是更小的，所以应该先调用try。

#### TCC可能存在的问题

1. 空回滚。发生的情景如下：事务管理器注册try操作成功，但后续调用try接口失败。往后会触发cancel操作，此时try接口对应的服务会在没有try的情况下回滚。要解决这个问题，需要在try操作成功后进行记录，如果在cancel时没有对应的事务记录，则不回滚。
2. 重复try。如果try操作超时，管理器会进行重试，此时就可能会重复try。解决方法可以直接沿用1中的事务记录。
3. 事务悬挂。是指先cancel，再try，对于下游服务来说，事务永远到达不了终态。发生的情况如下：注册完try后在调用try接口时，由于网络或者服务原因，请求一直没有处理，管理器会触发cancel操作。由于1中已经允许了空回滚，此时try对应的服务也会回滚。但是cancel后，try请求又继续处理了，此时该服务会被挂在一个try的中间状态。解决办法也是利用事务记录，当cancel时，记录一条已回滚的事务记录。这样当try后来时，判断是否有这样的记录，如果有了，则不需要操作。

### 可靠消息最终一致

TCC一般用于接口同步调用，但是现在很多模块之间使用的是异步方式，例如使用mq或者kafka等。这就需要使用可靠消息实现最终一致，核心思路和rocketmq的事务消息原理一致，都是将消息发送分成两步，先发prepare再发confirm。

大致原理如下：假设有三方，上游服务、消息服务、下游服务。

1. 上游服务先调用消息服务，发送prepare消息，保存在消息服务中，状态为待确认。
2. 上游服务执行本地事务，根据结果通知消息服务commit或者rollback上面1中的待确认消息。
3. commit情况下，消息服务保证可靠消息已经发送到消息队列，此时消息状态为已发送。rollback时，删除待确认消息。
4. 下游服务获取到上游发送的消息，开始处理本地业务。
5. 下游服务返回消息服务ack，通知完成消息处理。

下面讨论几种异常情况：

1. 上游处理完本地，但是通知消息服务失败。此时消息服务需要定时扫描待确认消息，并调用上游服务的查询接口，确认业务处理情况，成功则commit，失败则rollback。
2. 下游没有收到消息或者消费失败。此时消息服务也需要定时扫表已发送消息，并重新发送该消息。这要求下游服务支持幂等消费。
3. 如果下游收到消息，但是业务处理失败。这样其实是属于业务异常，不是分布式事务一致性问题，处理方案应该在业务流程中定义好。例如订单更新后，支付失败，那么应该将订单再修改成支付失败或者其他状态。

#### 异步方式存在的疑问

在TCC中可以由很多业务参与，但是在可靠消息中，目前网上看到的案例，都是只有两方。如果消息方式中有更多服务，应该怎么处理？

按照“龙果学院”的课程说法，

### 最大努力通知服务

对于一些附加业务，成功或失败都不会影响主流程的执行，这里用上述两种方案会显得太重，影响整体性能。在高并发情况下，甚至会主动关闭这些业务。针对这样的场景，可以使用最大努力通知服务。

上游应用将消息发送到mq，消息中可以包含通知规则、重试规则等，最大努力通知服务收到后解析通知规则放入任务队列。任务触发后按规则调用下游应用，成功则标记通知成功，如果失败则按照重试规则进行重试。

如果最终通知失败，可以返回上游一个通知失败消息。

## 怎么设计一个系统

前期：业务和需求的调研

需求的背景，需求的内容，服务的对象，对象的体量，业务的当前复杂度和后续可能的发展方向。需求中不同子功能的优先级、重要程度。

中期：系统的设计与开发

系统的总体设计，根据业务的核心流程。划分系统的不同模块，划分的原则是高内聚低耦合，关联性强的放在一个模块，同时考虑到做成单独服务的可能性。给不同模块定义不同的重要等级，对次要模块，采用简单、直接、有效的方式完成。
对重要的、相对复杂的模块，要考虑系统的性能、安全性等，比如流量如何，是否需要用缓存技术，业务量大小，考虑是用传统的关系数据库还是kv数据库，系统核心流程的熔断。安全性主要考虑的是数据的校验。
还有其他的技术选型，例如根据业务的复杂度和变化程度，考虑是否用到类似规则引擎来抽离多变的业务逻辑。
模块之前考虑交互方式，同步的是使用rpc还是使用http，异步一般都选用mq。这里还要考虑到交互过程中是否需要保证事务性，以及事务的完成方式。

后期：系统的监控、优化，业务的后续改进

监控主要包括业务的正常量、异常量、系统的平均响应、最大响应，以及各项业务指标，机器、数据库的load、磁盘等。