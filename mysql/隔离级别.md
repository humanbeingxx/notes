# mysql隔离级别

## 三种错误

### 脏读

某事务更新了数据，但是未提交，其他事务能读到未提交的数据。

### 不可重复读

一个事务中两次相同查询，结果不同，原因是读取到其他事务提交的数据。

### 幻读

一个事务的两次范围查询，读到不同条数。原因是其他事务插入了新数据。

## 四种隔离级别

### Read Uncommitted

所有事务都可以看到其他未提交事务的执行结果。

### Read Committed

一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读。

### Repeatable Read

同一事务的多个实例在并发读取数据时，会看到同样的数据行。会产生幻读。
是mysql默认级别。

### Serializable

强制事务排序，使之不可能相互冲突。

### 解决幻读问题——MVCC(Multiversion Concurrent Control)

每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。 \
基本原理是innodb给每一行添加了两个字段（实际v实现并不是这样）：创建时间和删除时间。

---

SELECT

Innodb检查每行数据，确保他们符合两个标准：

1、InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行

2、行的删除操作的版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有被删除

符合了以上两点则返回查询结果。

INSERT

InnoDB为每个新增行记录当前系统版本号作为创建ID。

DELETE

InnoDB为每个删除行的记录当前系统版本号作为行的删除ID。

UPDATE

InnoDB复制了一行。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。

---

insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；

update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；

delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；

select操作对两者都不修改，只读相应的数据

---

## 遗留问题

1. innodb实现的数据结构和方式是什么？
   答：基于undo日志。
2. 有时mysql的主键id不连续，和事务有关吗？
   答：不是，是和mysql的自增键锁有关。
3. 假如有事务A和B，A在B之前发生，如果实时根据事务id去比较，那么B应该能看到A的写入，但是实际上并不能，为什么？
   答：mysql中使用了read view机制来实现。
   > 规则 1 : 创建read review时会将当前最小事务号作为下限，使用这个read view的事务，不会看到事务号比这个下限大的事务。
   > 规则 2 : 使用这个read view的事务，不会看到创建read view时正活跃的事务。（read view创建时会拷贝一个当前活跃事务的副本）
4. delete标志的数据什么时候删除？
   答：purge线程。首先复制当前最小事务号的read view，然后判断数据的删除事务号是否小于view的事务号，则可以清理。
